import '../../_support/env';
import assert from 'assert';
import {DataType, In} from '@sqb/builder';
import {Column, Entity, PrimaryKey, SqbClient} from '@sqb/connect';
import {Customer} from '../../_support/customer.entity';
import {initClient} from '../../_support/init-client';
import {Tag} from '../../_support/tags.entity';

@Entity('customers')
export class Customer2 {
    @PrimaryKey()
    @Column({fieldName: 'id', dataType: DataType.BIGINT, autoGenerated: 'increment'})
    pk?: number;

    @Column({fieldName: 'given_name'})
    given?: string;

}

let client: () => SqbClient;

const createCustomer = async function (values?: any): Promise<Customer> {
    const v = {
        givenName: 'G' + Math.trunc(Math.random() * 10000),
        familyName: 'F' + Math.trunc(Math.random() * 10000),
        countryCode: 'TR',
        ...values
    }
    const repo = client().getRepository(Customer);
    return await repo.create(v);
}

describe('update()', function () {

    client = initClient();

    it('should update and return updated columns', async function () {
        const old = await createCustomer();

        const repo = client().getRepository(Customer);
        const newGivenName = 'G' + Math.trunc(Math.random() * 10000);
        const updated = await repo.update(old.id, {
            givenName: newGivenName
        });

        assert.ok(updated);
        assert.strictEqual(updated.id, old.id);
        assert.strictEqual(updated.givenName, newGivenName);
        assert.notStrictEqual(updated.givenName, old.givenName);

        const c2 = await repo.findByPk(old.id);
        assert.ok(c2);
        assert.strictEqual(c2.id, old.id);
        assert.strictEqual(c2.givenName, newGivenName);
        assert.notStrictEqual(c2.givenName, old.givenName);
    });

    it('should update even element name and field name differs', async function () {
        const old = await createCustomer();

        const repo = client().getRepository(Customer2);
        let sql = '';
        client().once('execute', request => {
            sql = request.sql;
        });
        const newGivenName = 'G' + Math.trunc(Math.random() * 10000);
        const updated = await repo.update(old.id, {
            given: newGivenName
        });

        assert.ok(updated);
        assert.strictEqual(sql, 'update customers T set given_name = $1 where T.id = $2');
        assert.strictEqual(updated.pk, old.id);
        assert.strictEqual(updated.given, newGivenName);
        assert.notStrictEqual(updated.given, old.givenName);

        const c2 = await repo.findByPk(old.id);
        assert.ok(c2);
        assert.strictEqual(updated.pk, c2.pk);
        assert.strictEqual(updated.given, c2.given);
    });

    it('should apply serialize function', async function () {
        const old = await createCustomer();

        const repo = client().getRepository(Customer);
        const newGivenName = 'G' + Math.trunc(Math.random() * 10000);
        const updated = await repo.update(old.id, {
            givenName: newGivenName,
            gender: 'Female'
        });
        const c2 = await repo.findByPk(old.id);
        assert.ok(c2);
        assert.strictEqual(updated.id, c2.id);
        assert.strictEqual(updated.gender, 'Female');
    });

    it('should work within transaction', async function () {
        return client().acquire(async (connection) => {
            const repo = connection.getRepository(Customer);
            const old = await createCustomer();

            await connection.startTransaction();
            const newGivenName = 'G' + Math.trunc(Math.random() * 10000);
            const updated = await repo.update(old.id, {
                givenName: newGivenName
            });
            assert.strictEqual(updated.givenName, newGivenName);

            await connection.rollback();
            const c2 = await repo.findByPk(old.id);
            assert.ok(c2);
            assert.strictEqual(c2.givenName, old.givenName);
        });
    });

    it('should check enum value', async function () {
        const repo = client().getRepository(Tag);
        await assert.rejects(() => repo.update(1, {name: 'small', color: 'pink'}),
            /value must be one of/);
    });

    it('should column is required', async function () {
        const repo = client().getRepository(Customer);
        await assert.rejects(() => repo.update(1, {countryCode: null}),
            /is required/);
    });

});


describe('updateOnly()', function () {

    client = initClient();

    it('should return "true" if update success', async function () {
        const repo = client().getRepository(Customer);
        const old = await createCustomer();
        const newGivenName = 'G' + Math.trunc(Math.random() * 10000);
        let success = await repo.updateOnly(old.id, {
            givenName: newGivenName
        });
        assert.strictEqual(success, true);

        success = await repo.updateOnly(0, {
            givenName: newGivenName
        });
        assert.strictEqual(success, false);

        const c2 = await repo.findByPk(old.id);
        assert.ok(c2);
        assert.strictEqual(c2.id, old.id);
        assert.strictEqual(c2.givenName, newGivenName);
    });

    it('should not fetch after update for fast execution', async function () {
        return client().acquire(async (connection) => {
            const repo = connection.getRepository(Customer);
            const old = await createCustomer();
            let sql = '';
            connection.on('execute', req => {
                sql = req.sql;
            });
            await repo.updateOnly(old.id, {
                givenName: 'any name'
            });
            assert.ok(!sql.includes('select'));
        });
    });

    it('should map embedded elements into fields', async function () {
        const repo = client().getRepository(Customer);
        const old = await createCustomer();
        const newName = {given: 'G' + Math.trunc(Math.random() * 10000)};
        const c1 = await repo.update(old.id, {
            name: newName
        });
        assert.ok(c1);
        assert.ok(c1 instanceof Customer);
        assert.strictEqual(c1.id, old.id);
        assert.strictEqual(c1.name.given, newName.given);
        assert.notStrictEqual(c1.name.given, old.name.given);

        const c2 = await repo.findByPk(old.id);
        assert.ok(c2);
        assert.ok(c2 instanceof Customer);
        assert.strictEqual(c2.id, old.id);
        assert.strictEqual(c2.name.given, newName.given);
    });

});

describe('updateAll()', function () {

    client = initClient();

    it('should update multiple rows', async function () {
        const oldCity = 'C' + Math.trunc(Math.random() * 10000);
        const ids: number[] = [];
        for (let i = 0; i < 10; i++) {
            const customer = await createCustomer({city: oldCity});
            ids.push(customer.id);
        }
        const repo = client().getRepository(Customer);
        const newCity = 'C' + Math.trunc(Math.random() * 10000);
        const count = await repo.updateAll({city: newCity}, {filter: In('id', ids)});
        assert.strictEqual(count, ids.length);
        const rows = await repo.findAll({filter: In('id', ids)});
        for (const row of rows) {
            assert.strictEqual(row.city, newCity);
        }
    });

});
