/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { DataType } from '@sqb/builder';
import { Column, Entity, PrimaryKey, SqbClient } from '@sqb/connect';
import { PartialDTO } from 'ts-gems';
import { Customer } from '../../_support/customer.entity.js';
import { initClient } from '../../_support/init-client.js';
import { Tag } from '../../_support/tags.entity.js';

@Entity('customers')
export class Customer2 {
  @PrimaryKey()
  @Column({ fieldName: 'id', dataType: DataType.BIGINT, autoGenerated: 'increment' })
  pk?: number;

  @Column({ fieldName: 'given_name' })
  given?: string;
}

export const createCustomer = async function (client: SqbClient, values?: any): Promise<PartialDTO<Customer>> {
  const v = {
    givenName: 'G' + Math.trunc(Math.random() * 10000),
    familyName: 'F' + Math.trunc(Math.random() * 10000),
    countryCode: 'TR',
    ...values,
  };
  const repo = client.getRepository(Customer);
  return await repo.create(v);
};

describe('Repository.update()', () => {
  let client: SqbClient;

  beforeAll(async () => {
    client = await initClient();
  });

  afterAll(async () => {
    await client.close(0);
  });

  it('should update and return updated columns', async () => {
    const old = await createCustomer(client);

    const repo = client.getRepository(Customer);
    const newGivenName = 'G' + Math.trunc(Math.random() * 10000);
    const updated = await repo.update(old.id, {
      givenName: newGivenName,
    });

    expect(updated).toBeDefined();
    expect(updated!.id).toStrictEqual(old.id);
    expect(updated!.givenName).toStrictEqual(newGivenName);
    expect(updated!.givenName).not.toStrictEqual(old.givenName);

    const c2 = await repo.findById(old.id);
    expect(c2).toBeDefined();
    expect(c2!.id).toStrictEqual(old.id);
    expect(c2!.givenName).toStrictEqual(newGivenName);
    expect(c2!.givenName).not.toStrictEqual(old.givenName);
  });

  it('should update even element name and field name differs', async () => {
    const old = await createCustomer(client);

    const repo = client.getRepository(Customer2);
    let sql = '';
    client.once('execute', request => {
      sql = request.sql;
    });
    const newGivenName = 'G' + Math.trunc(Math.random() * 10000);
    const updated = await repo.update(old.id, {
      given: newGivenName,
    });

    expect(updated).toBeDefined();
    expect(sql).toStrictEqual('update customers T set given_name = $1 where T.id = $2');
    expect(updated!.pk).toStrictEqual(old.id);
    expect(updated!.given).toStrictEqual(newGivenName);
    expect(updated!.given).not.toStrictEqual(old.givenName);

    const c2 = await repo.findById(old.id);
    expect(c2).toBeDefined();
    expect(updated!.pk).toStrictEqual(c2!.pk);
    expect(updated!.given).toStrictEqual(c2!.given);
  });

  it('should apply serialize function', async () => {
    const old = await createCustomer(client);

    const repo = client.getRepository(Customer);
    const newGivenName = 'G' + Math.trunc(Math.random() * 10000);
    const updated = await repo.update(old.id, {
      givenName: newGivenName,
      gender: 'Female',
    });
    const c2 = await repo.findById(old.id);
    expect(c2).toBeDefined();
    expect(updated!.id).toStrictEqual(c2!.id);
    expect(updated!.gender).toStrictEqual('Female');
  });

  it('should work within transaction', async () =>
    client.acquire(async connection => {
      const repo = connection.getRepository(Customer);
      const old = await createCustomer(client);

      await connection.startTransaction();
      const newGivenName = 'G' + Math.trunc(Math.random() * 10000);
      const updated = await repo.update(old.id, {
        givenName: newGivenName,
      });
      expect(updated!.givenName).toStrictEqual(newGivenName);

      await connection.rollback();
      const c2 = await repo.findById(old.id);
      expect(c2).toBeDefined();
      expect(c2!.givenName).toStrictEqual(old.givenName);
    }));

  it('should check enum value', async () => {
    const repo = client.getRepository(Tag);
    await expect(() => repo.update(1, { name: 'small', color: 'pink' })).rejects.toThrow('value must be one of');
  });

  it('should column is required', async () => {
    const repo = client.getRepository(Customer);
    await expect(() => repo.update(1, { countryCode: null })).rejects.toThrow('is required');
  });
});
