import {Param, Update} from '@sqb/builder';
import {QueryExecutor, QueryResult} from '../../client/types';
import {EntityMeta} from '../metadata/entity-meta';
import {extractKeyValues} from './keyvalues.helper';
import {wrapCreateResult} from './wrap.helper';
import {Repository} from '../repository';
import {Maybe, PartialWritable} from '../../types';
import {isDataColumn} from '../metadata/data-column-meta';

export type UpdateAllCommandArgs<T> = {
    executor: QueryExecutor;
    entityDef: EntityMeta;
    values: PartialWritable<T>;
    returnAutoGeneratedColumns?: boolean;
} & Repository.UpdateAllOptions;

export async function updateAllRaw<T>(args: UpdateAllCommandArgs<T>): Promise<Maybe<QueryResult>> {
    const tableName = args.entityDef.tableName;
    if (!tableName)
        throw new Error(`${args.entityDef.ctor.name} is not decorated with @Entity decorator`);
    const {entityDef, executor, values, filter, params, returnAutoGeneratedColumns} = args;
    const input = {};
    const _params = {...params};
    const returning: string[] | undefined = returnAutoGeneratedColumns ? [] : undefined;
    let v;
    let colCount = 0;

    for (const col of entityDef.elements.values()) {
        if (isDataColumn(col)) {
            if (returning && col.autoGenerated && !col.noUpdate)
                returning.push(col.fieldName);
            v = values[col.name];
            if (typeof col.serialize === 'function')
                v = col.serialize(v, col, values);
            if (v === undefined || col.noUpdate)
                continue;
            colCount++;
            input[col.fieldName] = Param({
                name: '$input_' + col.fieldName,
                dataType: col.dataType,
                isArray: col.isArray
            });
            _params['$input_' + col.fieldName] = v;
        }
    }
    if (colCount === 0)
        return;
    const query = Update(tableName, input)
        .where(filter);
    if (returning && returning.length)
        query.returning(...returning);
    return await executor.execute(query, {
        params: _params,
        objectRows: false,
        cursor: false
    });
}

export async function update<T>(args: {
    executor: QueryExecutor,
    entityDef: EntityMeta,
    values: PartialWritable<T>,
    returnAutoGeneratedColumns?: boolean
}): Promise<T | undefined> {
    const {executor, entityDef, values, returnAutoGeneratedColumns} = args;

    // Key values are used to filter records, so we remove them from values
    const keyValues = extractKeyValues<T>(entityDef, values);
    const _values = {};
    for (const k of Object.keys(values)) {
        const col = entityDef.getColumn(k);
        if (col && !keyValues.hasOwnProperty(col.name))
            _values[k] = values[k];
    }

    const filter = {};
    for (const k of Object.keys(keyValues)) {
        const col = entityDef.getColumn(k);
        if (isDataColumn(col))
            filter[col.fieldName] = Param({name: k, dataType: col.dataType, isArray: col.isArray});
    }

    const r = await updateAllRaw({
        executor,
        entityDef,
        values: _values,
        filter,
        params: keyValues,
        returnAutoGeneratedColumns
    });
    return r && r.rowsAffected ?
        wrapCreateResult(entityDef, values, r) : undefined;
}
