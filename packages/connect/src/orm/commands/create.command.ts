import {Insert, Param} from '@sqb/builder';
import {QueryExecutor, QueryResult} from '../../client/types';
import {wrapCreateResult} from './wrap.helper';
import {EntityMeta} from '../metadata/entity-meta';
import {PartialWritable} from '../../types';
import {isDataColumn} from '../metadata/data-column-meta';
import {isEmbeddedElement} from '../metadata/embedded-element-meta';

export interface CreateCommandArgs<T> {
    executor: QueryExecutor;
    entityDef: EntityMeta;
    values: PartialWritable<T>;
    returnAutoGeneratedColumns?: boolean;
}

/**
 *
 */
export async function createRaw<T>(args: CreateCommandArgs<T>): Promise<{
    executeTime: number;
    row?: T
}> {
    const tableName = args.entityDef.tableName;
    if (!tableName)
        throw new Error(`${args.entityDef.ctor.name} is not decorated with @Entity decorator`);
    const {executor, entityDef, values, returnAutoGeneratedColumns} = args;
    const inputParams = {};
    const inputValues = {};
    const returning = returnAutoGeneratedColumns && entityDef.primaryIndex?.columns;
    await iterateElements(entityDef, inputParams, inputValues, values);
    const query = Insert(tableName, inputParams);
    if (returning && returning.length)
        query.returning(...returning);
    const qr = await executor.execute(query, {
        params: inputValues,
        objectRows: false,
        cursor: false
    });

    return qr;
}

async function iterateElements(entity: EntityMeta,
                               inputParams: any,
                               inputValues: any,
                               srcValues: any) {
    let v;
    for (const col of entity.elements.values()) {
        v = srcValues[col.name];
        if (isDataColumn(col)) {
            if (col.noInsert)
                continue;
            if (typeof col.serialize === 'function')
                v = col.serialize(v, col, srcValues);
            if (v === undefined)
                continue;
            inputParams[col.fieldName] = Param({
                name: col.fieldName,
                dataType: col.dataType,
                isArray: col.isArray
            });
            inputValues[col.fieldName] = v;
        } else if (v != null && isEmbeddedElement(col)) {
            const type = await col.resolveType();
            await iterateElements(type, inputParams, inputValues, v);
        }
    }
}

/**
 *
 */
export async function create<T>(args: CreateCommandArgs<T>): Promise<T> {
    const {entityDef, values} = args;
    const r = await createRaw(args);
    return wrapCreateResult(entityDef, values, r);
}
