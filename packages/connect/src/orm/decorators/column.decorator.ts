import {DataType} from '@sqb/builder';
import {ColumnAutoGenerationStrategy, ColumnOptions, EnumValue, FieldValue, DefaultValueGetter} from '../types';
import {EntityMeta} from '../metadata/entity-meta';

export function Column(type?: DataType): PropertyDecorator
export function Column(options?: ColumnOptions): PropertyDecorator
export function Column(arg0?: DataType | ColumnOptions): PropertyDecorator {
    return (target: Object, propertyKey: string | symbol): void => {
        if (typeof propertyKey !== 'string')
            throw new Error('Symbol properties are not accepted');
        const options = typeof arg0 === 'string' ? {dataType: arg0} : arg0;
        EntityMeta.attachTo(target.constructor)
            .defineColumnElement(propertyKey, options);
    }
}

export function AutoGenerated(strategy: ColumnAutoGenerationStrategy): PropertyDecorator {
    return (target: Object, propertyKey: string | symbol): void => {
        if (typeof propertyKey !== 'string')
            throw new Error('You can define a Column for only string properties');
        EntityMeta.attachTo(target.constructor)
            .defineColumnElement(propertyKey, {autoGenerated: strategy});
    }
}

export function Default(v: FieldValue | DefaultValueGetter): PropertyDecorator {
    return (target: Object, propertyKey: string | symbol): void => {
        if (typeof propertyKey !== 'string')
            throw new Error('You can define a Column for only string properties');
        EntityMeta.attachTo(target.constructor)
            .defineColumnElement(propertyKey, {defaultValue: v});
    }
}

export function Enum(enumValue: EnumValue): PropertyDecorator {
    return (target: Object, propertyKey: string | symbol): void => {
        if (typeof propertyKey !== 'string')
            throw new Error('You can define a Column for only string properties');
        EntityMeta.attachTo(target.constructor)
            .defineColumnElement(propertyKey, {enum: enumValue});
    }
}

export function Precision(precision: number, scale?: number): PropertyDecorator {
    return (target: Object, propertyKey: string | symbol): void => {
        if (typeof propertyKey !== 'string')
            throw new Error('You can define a Column for only string properties');
        EntityMeta.attachTo(target.constructor)
            .defineColumnElement(propertyKey, {precision, scale});
    }
}

export function Length(length: number): PropertyDecorator {
    return (target: Object, propertyKey: string | symbol): void => {
        if (typeof propertyKey !== 'string')
            throw new Error('You can define a Column for only string properties');
        EntityMeta.attachTo(target.constructor)
            .defineColumnElement(propertyKey, {length});
    }
}


export function FieldName(fieldName: string): PropertyDecorator {
    return (target: Object, propertyKey: string | symbol): void => {
        if (typeof propertyKey !== 'string')
            throw new Error('You can define a Column for only string properties');
        EntityMeta.attachTo(target.constructor)
            .defineColumnElement(propertyKey, {fieldName})
    }
}

export function Comment(comment: string): PropertyDecorator {
    return (target: Object, propertyKey: string | symbol): void => {
        if (typeof propertyKey !== 'string')
            throw new Error('You can define a Column for only string properties');
        EntityMeta.attachTo(target.constructor)
            .defineColumnElement(propertyKey, {comment});
    }
}

export function NotNull(target: Object, propertyKey: string | symbol): void {
    if (typeof propertyKey !== 'string')
        throw new Error('You can define a Column for only string properties');
    EntityMeta.attachTo(target.constructor)
        .defineColumnElement(propertyKey, {notNull: true});
}

export function Hidden(target: Object, propertyKey: string | symbol): void {
    if (typeof propertyKey !== 'string')
        throw new Error('You can define a Column for only string properties');
    EntityMeta.attachTo(target.constructor)
        .defineColumnElement(propertyKey, {hidden: true});
}

export function NoUpdate(target: Object, propertyKey: string | symbol): void {
    if (typeof propertyKey !== 'string')
        throw new Error('You can define a Column for only string properties');
    EntityMeta.attachTo(target.constructor)
        .defineColumnElement(propertyKey, {noUpdate: true});
}

export function NoInsert(target: Object, propertyKey: string | symbol): void {
    if (typeof propertyKey !== 'string')
        throw new Error('You can define a Column for only string properties');
    EntityMeta.attachTo(target.constructor)
        .defineColumnElement(propertyKey, {noInsert: true});
}
