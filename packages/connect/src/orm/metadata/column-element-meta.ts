import 'reflect-metadata';
import _ from 'lodash';
import {DataType} from '@sqb/builder';
import type {EntityMeta} from './entity-meta';
import {
    ElementKind,
    ColumnAutoGenerationStrategy,
    ColumnTransformFunction, ColumnOptions, EnumValue, FieldValue, DefaultValueGetter,
} from '../types';
import {AbstractElementMeta} from './abstract-element-meta';

export function isColumnElement(f: any): f is ColumnElementMeta {
    return !!(f && f instanceof AbstractElementMeta && f.kind === 'data');
}

export class ColumnElementMeta extends AbstractElementMeta {
    readonly kind: ElementKind = 'data';
    fieldName: string;
    dataType?: DataType;
    type?: Function;

    /**
     * Field comment
     */
    comment?: string;

    /**
     * Column's default value
     */
    defaultValue?: FieldValue | DefaultValueGetter;

    /**
     * Indicates if column data is an array
     */
    isArray?: boolean;

    /**
     * Indicates enum values
     */
    enum?: EnumValue;

    /**
     * Character or byte length of column
     */
    length?: number;

    /**
     * The precision for a decimal field
     */
    precision?: number;

    /**
     * The scale for a decimal field
     */
    scale?: number;

    /**
     * Fields's collation.
     */
    collation?: string;

    /**
     * Indicates auto generation strategy
     */
    autoGenerated?: ColumnAutoGenerationStrategy;

    /**
     * Indicates if column value can be null
     */
    notNull?: boolean;

    /**
     * Indicates whether or not to hide this column by default when making queries.
     */
    hidden?: boolean;

    /**
     * Indicates if column value is used in update queries
     */
    noUpdate?: boolean;

    /**
     * Indicates if column value is used in insert queries
     */
    noInsert?: boolean;

    parse?: ColumnTransformFunction;
    serialize?: ColumnTransformFunction;

    constructor(entity: EntityMeta, name: string, options: ColumnOptions = {}) {
        super(entity, name);
        this.fieldName = name;
        if (options)
            this.assign(options);
    }

    assign(options: ColumnOptions) {
        Object.assign(this, _.omit(options, ['entity', 'name', 'kind']));
    }

    checkEnumValue(v: FieldValue) {
        if (v === undefined || !this.enum)
            return;
        const enumKeys = Array.isArray(this.enum) ? this.enum : Object.keys(this.enum);
        if (!enumKeys.includes(v))
            throw new Error(`${this.entity.name}.${this.name} value must be one of (${enumKeys})`);
    }

}
