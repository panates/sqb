import 'reflect-metadata';
import _ from 'lodash';
import {DataType} from '@sqb/builder';
import type {EntityModel} from './entity-model';
import {
    ElementKind,
    ColumnAutoGenerationStrategy,
    ColumnTransformFunction, DataPropertyOptions, EnumValue, FieldValue, DefaultValueGetter,
} from '../orm.type';
import {AbstractEntityElement} from './abstract-entity-element';

export class EntityColumnElement extends AbstractEntityElement {
    readonly kind: ElementKind = 'column';
    fieldName: string;
    dataType?: DataType;
    type?: Function;

    /**
     * Field comment
     */
    comment?: string;

    /**
     * Column's default value
     */
    default?: FieldValue | DefaultValueGetter;

    /**
     * Indicates if column data is an array
     */
    isArray?: boolean;

    /**
     * Indicates enum values
     */
    enum?: EnumValue;

    /**
     * Character or byte length of column
     */
    length?: number;

    /**
     * The precision for a decimal field
     */
    precision?: number;

    /**
     * The scale for a decimal field
     */
    scale?: number;

    /**
     * Fields's collation.
     */
    collation?: string;

    /**
     * Indicates auto generation strategy
     */
    autoGenerated?: ColumnAutoGenerationStrategy;

    /**
     * Indicates if column value can be null
     */
    notNull?: boolean;

    /**
     * Indicates whether or not to hide this column by default when making queries.
     */
    hidden?: boolean;

    /**
     * Indicates if column value is used in update queries
     */
    noUpdate?: boolean;

    /**
     * Indicates if column value is used in insert queries
     */
    noInsert?: boolean;

    parse?: ColumnTransformFunction;
    serialize?: ColumnTransformFunction;

    constructor(entity: EntityModel, name: string, options: DataPropertyOptions = {}) {
        super(entity, name);
        this.fieldName = name;
        if (options)
            this.assign(options);
    }

    assign(options: DataPropertyOptions) {
        Object.assign(this, _.omit(options, ['entity', 'name', 'kind']));
    }

    checkEnumValue(v: FieldValue) {
        if (v === undefined || !this.enum || (v == null && !this.notNull))
            return;
        const enumKeys = Array.isArray(this.enum) ? this.enum : Object.keys(this.enum);
        if (!enumKeys.includes(v))
            throw new Error(`${this.entity.name}.${this.name} value must be one of (${enumKeys})`);
    }

}
