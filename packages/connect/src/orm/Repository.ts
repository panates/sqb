import {
    Operator
} from '@sqb/builder';
import {Client} from '../client/Client';
import {Connection} from '../client/Connection';
import {Constructor, PickWritable} from './orm.types';
import {EntityDefinition} from './EntityDefinition';
import {QueryExecutor} from '../client/types';
import {Maybe} from '../types';

import {extractKeyValues} from './commands/keyvalues.helper';
import {count} from './commands/count.command';
import {create, createRaw} from './commands/create.command';
import {findAll} from './commands/find.command';
import {destroyAll} from './commands/destroy.command';
import {update, updateAllRaw} from './commands/update.command';


export namespace Repository {

    export type SearchFilter = object | Operator | (object | Operator)[];

    export interface CountOptions {
        filter?: SearchFilter;
        params?: any;
    }

    export interface GetOptions {
        columns?: string[];
    }

    export interface FindOneOptions {
        columns?: string[];
        filter?: SearchFilter;
        params?: any;
        sort?: string[];
        offset?: number;
    }

    export interface FindAllOptions extends FindOneOptions {
        limit?: number;
        maxEagerFetch?: number;
    }

    export interface RemoveOptions {
        filter?: SearchFilter;
        params?: any;
    }

    export interface UpdateOptions {

    }

    export interface UpdateAllOptions {
        filter?: SearchFilter;
        params?: any;
    }

}

export class Repository<T> {
    private readonly _client: Client;
    private readonly _executor: QueryExecutor;
    private readonly _entityDef: EntityDefinition;
    private readonly _ctor: Constructor;

    constructor(client: Client | Connection, ctor: Constructor) {
        if (client instanceof Client) {
            this._client = client;
            this._executor = client;
        } else {
            this._executor = client;
            this._client = client.client;
        }
        this._ctor = ctor;
        this._entityDef = EntityDefinition.get(ctor);
    }

    async create(values: Partial<PickWritable<T>>): Promise<T> {
        return create<T>({
            executor: this._executor,
            entityDef: this._entityDef,
            values,
            returnAutoGeneratedColumns: true
        });
    }

    async createOnly(values: Partial<PickWritable<T>>): Promise<void> {
        await createRaw<T>({
            executor: this._executor,
            entityDef: this._entityDef,
            values
        });
    }

    count(options?: Repository.CountOptions): Promise<number> {
        return count({
            executor: this._executor,
            entityDef: this._entityDef,
            filter: options?.filter,
            params: options?.params
        });
    }

    findAll(options?: Repository.FindAllOptions): Promise<T[]> {
        return findAll({
            ...options,
            executor: this._executor,
            entityDef: this._entityDef
        });
    }

    async findOne(options?: Repository.FindOneOptions): Promise<Maybe<T>> {
        const rows = await findAll({
            ...options,
            limit: 1,
            executor: this._executor,
            entityDef: this._entityDef
        });
        return rows && rows[0];
    }

    async get(keyValue: T | any | Record<string, any>, options?: Repository.GetOptions): Promise<Maybe<T>> {
        const opts: Repository.FindAllOptions = {...options};
        opts.filter = [extractKeyValues(this._entityDef, keyValue)];
        opts.limit = 1;
        delete opts.offset;
        return await this.findOne(opts);
    }

    async destroy(keyValue: T | any | Record<string, any>): Promise<boolean> {
        return !!(await destroyAll({
            executor: this._executor,
            entityDef: this._entityDef,
            filter: extractKeyValues(this._entityDef, keyValue)
        }));
    }

    async destroyAll(options?: Repository.RemoveOptions): Promise<number> {
        return destroyAll({
            executor: this._executor,
            entityDef: this._entityDef,
            filter: options?.filter,
            params: options?.params
        });
    }

    async update(values: Partial<PickWritable<T>>): Promise<Partial<T> | undefined> {
        return update({
            executor: this._executor,
            entityDef: this._entityDef,
            values,
            returnAutoGeneratedColumns: true
        });
    }

    async updateOnly(values: Partial<PickWritable<T>>): Promise<boolean> {
        const x = await update({
            executor: this._executor,
            entityDef: this._entityDef,
            values,
            returnAutoGeneratedColumns: false
        })
        return !!x;
    }

    async updateAll(values: Partial<PickWritable<T>>, options?: Repository.UpdateAllOptions): Promise<number> {
        const r = await updateAllRaw<T>({
            executor: this._executor,
            entityDef: this._entityDef,
            values,
            filter: options?.filter,
            params: options?.params
        });
        return (r && r.rowsAffected) || 0;
    }

}
